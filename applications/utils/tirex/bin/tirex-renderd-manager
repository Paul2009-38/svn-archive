#!/usr/bin/perl
#-----------------------------------------------------------------------------
#
#  Tirex Tile Rendering System
#
#  tirex-renderd-manager
#
#-----------------------------------------------------------------------------
#
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#  ALPHA version of new renderd starter. not usable yet!
#
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#-----------------------------------------------------------------------------
#  See end of this file for documentation.
#-----------------------------------------------------------------------------
#
#  Copyright (C) 2010  Frederik Ramm <frederik.ramm@geofabrik.de> and
#                      Jochen Topf <jochen.topf@geofabrik.de>
#  
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; If not, see <http://www.gnu.org/licenses/>.
#
#-----------------------------------------------------------------------------

use strict;
use warnings;

use Getopt::Long qw( :config gnu_getopt );
use Socket;
use IO::Socket;
use IO::Select;
use IO::Pipe;
use Sys::Syslog;
use POSIX qw(sys_wait_h setsid);
use Fcntl;

use Tirex;
use Tirex::Renderer;
use Tirex::Map;

#-----------------------------------------------------------------------------

die('refusing to run as root') if ($< == 0);

#-----------------------------------------------------------------------------
# Reading command line and config
#-----------------------------------------------------------------------------

my %opts = ();
GetOptions( \%opts, 'help|h', 'debug|d', 'config|c=s' ) or exit(2);

if ($opts{'help'})
{
    pod2usage(
        -verbose => 1,
        -msg     => "tirex-renderd-manager - tirex rendering manager\n",
        -exitval => 0
    );
}

if ($opts{'debug'})
{
    $Tirex::DEBUG = $opts{'debug'};
}

my $config_file = ($opts{'config'} || $Tirex::TIREX_CONFIGDIR) . '/' . $Tirex::TIREX_CONFIGFILENAME;
Tirex::Config::init($config_file);

read_renderer_and_map_config();

#-----------------------------------------------------------------------------

my $port = Tirex::Config::get('renderd_udp_port', $Tirex::RENDERD_UDP_PORT, qr{^[1-9][0-9]{0,4}$});
my $pidfile = $Tirex::RENDERD_PIDFILE;

# children must check in every so often; note they will not check
# in during tile rendering so allow ample time.
my $alive_timeout = $Tirex::RENDERD_ALIVE_TIMEOUT * 60;

# a child that has been sent a signal must react this quickly
my $hangup_timeout = 15;
my $term_timeout = 2;

#-----------------------------------------------------------------------------
# create socket for children to send heartbeat to
#-----------------------------------------------------------------------------
my $socket = IO::Socket::INET->new(
    LocalAddr => 'localhost', 
    LocalPort => $port, 
    Proto     => 'udp', 
    ReuseAddr => 1) or die("Cannot open UDP socket: :$!\n");
$socket->fcntl(F_SETFD, 0); # unset close-on-exec
# XXX push(@worker_args, "--sockfd", $socket->fileno());

#-----------------------------------------------------------------------------
# daemonize and create pidfile
#-----------------------------------------------------------------------------
if (! $Tirex::DEBUG)
{
    chdir('/')                     or die("Cannot chdir to /: $!");
    open(STDIN,  '<', '/dev/null') or die("Cannot read from /dev/null: $!");
    open(STDOUT, '>', '/dev/null') or die("Cannot write to /dev/null: $!");
    defined(my $pid = fork)        or die("Cannot fork: $!");
    exit(0) if ($pid);
    setsid()                       or die("Cannot start a new session: $!");
    open(STDERR, '>&STDOUT')       or die("Cannot dup stdout: $!");
}

# open pidfile, ignore if this fails
# we'd rather go on without a pidfile than stopping the show
if (open(my $pidfh, '>', $pidfile)) 
{
    print $pidfh "$$\n";
    close($pidfh);
}

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
$SIG{CHLD} = \&sigchld_handler;
$SIG{HUP}  = \&sighup_handler;
$SIG{TERM} = \&sigterm_handler;
$SIG{INT}  = \&sigterm_handler;

openlog('tirex-renderd-manager', $Tirex::DEBUG ? 'pid|perror' : 'pid', 'daemon');
syslog('info', 'tirex-renderd-manager started');

my @renderers = Tirex::Renderer->all();
syslog('info', 'found config for renderers: %s', join(' ', map { $_->get_name(); } @renderers));

my $workers = {};
my @closed_children = ();

while (1)
{
    foreach my $renderer (@renderers)
    {
        while ($renderer->num_workers() < $renderer->get_procs())
        {
            my $reader = IO::Pipe::End->new();
            my $writer = IO::Pipe::End->new();
            my $pipe = IO::Pipe->new($reader, $writer);
            $reader->fcntl(F_SETFD, 0); # unset close-on-exec
            $writer->fcntl(F_SETFD, 0); # unset close-on-exec
            $reader->blocking(0);
            $writer->blocking(0);

            my $pid = fork();
            if ($pid == 0) # child
            {
                $pipe->writer();

                execute_renderer($renderer, $pipe->fileno());

                # if we are here the execute failed, send the parent a notice so that he can disable the renderer
                $pipe->write('X', 1);

                exit(0);
            }
            elsif ($pid > 0) # parent
            {
                $pipe->reader();

                syslog('info', 'renderd %s started with pid %d', $renderer->get_name(), $pid);

                $workers->{$pid} = { 
                    pid          => $pid,
                    last_contact => time(),
                    handle       => $pipe,
                    renderer     => $renderer,
                };
                $renderer->add_worker($pid);
            }
            else
            {
                syslog('err', 'error in fork(): %s', $!);
            }
        }
    }

    my $select = IO::Select->new();
    foreach my $worker (values %$workers)
    {
        $select->add([$worker->{'handle'}, $worker]);
    }

    my $now = time();
    foreach my $handle_wrapper ($select->can_read($alive_timeout / 2))
    {
        my ($handle, $worker) = @$handle_wrapper;
        my $buf;
        $handle->read($buf, 9999);
        if (length($buf) > 0)
        {
            $worker->{'last_contact'} = $now;
        }
        if ($buf =~ /X/)
        {
            my $renderer = $worker->{'renderer'};
            syslog('crit', 'cannot execute renderer %s (%s). disabled.', $renderer->get_name(), $renderer->get_path());
            @renderers = grep { $_ ne $renderer } @renderers;
        }
        if ($buf =~ /C/)
        {
            my $renderer = $worker->{'renderer'};
            syslog('crit', 'cannot configure renderer %s (%s). disabled.', $renderer->get_name());
            @renderers = grep { $_ ne $renderer } @renderers;
        }
    }

    # remove dead children from the worker list
    while (my $pid = shift @closed_children)
    {
        $workers->{$pid}->{'handle'}->close();
        $workers->{$pid}->{'renderer'}->remove_worker($pid);
        delete $workers->{$pid};
    }

    # kill workers that haven't said anything for a while
    foreach my $worker (values %$workers) 
    { 
        if ($worker->{'last_contact'} < $now - $alive_timeout)
        {
            if (! defined($worker->{'killed'}) && defined($worker->{'terminated'}) && ($worker->{'terminated'} < $now - $term_timeout))
            {
                syslog('info', 'sending sigkill to pid %d', $worker->{'pid'});
                kill('KILL', $worker->{'pid'});
                $worker->{'killed'} = $now;
            }
            elsif (! defined($worker->{'terminated'}) && defined($worker->{'hungup'}) && ($worker->{'hungup'} < $now - $hangup_timeout))
            {
                syslog('info', 'sending sigterm to pid %d', $worker->{'pid'});
                kill('TERM', $worker->{'pid'});
                $worker->{'terminated'} = $now;
            }
            elsif (! defined($worker->{'hungup'}))
            {
                syslog('err', 'killing child with pid %d due to timeout', $worker->{'pid'});
                kill('HUP', $worker->{'pid'});
                $worker->{'hungup'} = $now;
            }
        }
    }
}

#-----------------------------------------------------------------------------

sub execute_renderer
{
    my $renderer    = shift;
    my $pipe_fileno = shift;

    $ENV{'TIREX_RENDERD_NAME'}            = $renderer->get_name();
    $ENV{'TIREX_RENDERD_PORT'}            = $renderer->get_port();
    $ENV{'TIREX_RENDERD_SYSLOG_FACILITY'} = $renderer->get_syslog_facility();
    $ENV{'TIREX_RENDERD_MAPFILES'}        = join(' ', map { $_->get_filename() } grep { $_->get_renderer() eq $renderer } Tirex::Map->all());
    $ENV{'TIREX_RENDERD_DEBUG'}           = $Tirex::DEBUG;
    $ENV{'TIREX_RENDERD_PIPE_FILENO'}     = $pipe_fileno;
    $ENV{'TIREX_RENDERD_ALIVE_TIMEOUT'}   = $alive_timeout - 20; # give the child 20 seconds less than what the parent uses as timeout to be on the safe side

    exec($renderer->get_path());
}


#-----------------------------------------------------------------------------
# Signal handler
#-----------------------------------------------------------------------------
sub sigchld_handler 
{
    while ((my $child = waitpid(-1, WNOHANG)) > 0) 
    {
        syslog('warning', 'child %d terminated (%d)', $child, $?);
        push(@closed_children, $child);
    }
    $SIG{'CHLD'} = \&sigchld_handler;
}

sub sighup_handler 
{
    syslog('info', 'hangup received, forwarding to children: %s', join(' ', keys %$workers));
    foreach my $pid (keys %$workers)
    {
        kill('HUP', $pid);
    }
    $SIG{'HUP'} = \&sighup_handler;
}

sub sigterm_handler 
{
    syslog('info', 'sigterm/int received, forwarding to children: %s', join(' ', keys %$workers));
    foreach my $pid (keys %$workers)
    {
        kill('HUP', $pid);
    }
    exit(0);
}


#-----------------------------------------------------------------------------
sub read_renderer_and_map_config
{
    my $dir = $opts{'config'} || $Tirex::TIREX_CONFIGDIR;

    foreach my $file (glob("$dir/renderer/*"))
    {
        Tirex::Renderer->new_from_configfile($file);
    }

    foreach my $file (glob("$dir/maps/*"))
    {
        Tirex::Map->new_from_configfile($file);
    }
}

__END__

=head1 NAME

tirex-renderd-manager - program that spawns tirex-renderd processes

=head1 SYNOPSIS

tirex-renderd-manager [OPTIONS] 

=head1 OPTIONS

=over 4

=item B<--help>

Display help message.

=item B<-d>, B<--debug>

Run in debug mode, and pass on the debug flag to spawned processes

=item B<--config=FILE>

Use the config file FILE instead of /etc/tirex/tirex.conf.

=item B<--dummy>

Start a dummy rendering process instead of the real thing.

=item B<--dummy-sleeptime=I<seconds>>

Instruct the dummy renderer to wait for I<seconds> seconds before answering
a request.

=item further command line options

All other command line options are passed on verbatim to the renderer process
being started.

=back

=head1 DESCRIPTION

tirex-renderd-starter runs the renderd starter. This is usually done
from within an /etc/init.d script. The renderd starter spawns as many
tirex-renderd processes as given in the configuration, and monitors
them.

The renderd starter does not handle render requests in any way; these
are read directly from a local UDP socket by the individual tirex-ren-
derd processes.

The renderd starter expects each tirex-renderd process to send an
"alive" message in regular intervals, and will kill the process if it
does not do so in time.

In addition, if the starter receives a HANGUP signal, it will relay
this signal to all tirex-renderd children, causing them to exit after
completing their current request.

If the starter receives a KILL signal, it will send a HANGUP signal to
all tirex-renderd children and then exit.

opens a socket and binds it to the proper port (usually 9320),
then starts a number of /usr/bin/tirex-renderd processes
(the number can be configured using the renderd_processes option).
These children are all options received by this script, plus
an additional "--sockfd" option with the file descriptor of the 
socket opened, and a "--parentfd" with the file descriptor of 
a pipe that the child can use to send messages to the starter.

When children die, they are restarted.

If children freeze (and stop sending "alive" messages) they are
killed.

If this process receives a HUP or TERM signal, it sends a HUP signal 
to all children and continues (if the signal received was HUP) or
terminates (if TERM).

For debugging you can set the config option renderd_dummy to 1. This
still forks but instead of rendering just waits for a number of
seconds (specified in the config option renderd_dummy_sleeptime).

=head1 FILES

=over 4

=item F</etc/tirex/tirex.conf>

The configuration file. See tirex.conf(5) for further details.

=back

=head1 DIAGNOSTICS

The renderd starter logs to the I<daemon> syslog facility unless configured
otherwise. In debug mode, logging is also copied to stdout.

=head1 AUTHORS

Frederik Ramm <frederik.ramm@geofabrik.de>, Jochen Topf
<jochen.topf@geofabrik.de> and possibly others.

=cut

#-- THE END ------------------------------------------------------------------
