#!/usr/bin/perl
#-----------------------------------------------------------------------------
#
#  Tirex Tile Rendering System
#
#  tirex-renderd-manager
#
#-----------------------------------------------------------------------------
#  See end of this file for documentation.
#-----------------------------------------------------------------------------
#
#  Copyright (C) 2010  Frederik Ramm <frederik.ramm@geofabrik.de> and
#                      Jochen Topf <jochen.topf@geofabrik.de>
#  
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; If not, see <http://www.gnu.org/licenses/>.
#
#-----------------------------------------------------------------------------

use strict;
use warnings;

use Getopt::Long qw( :config gnu_getopt );
use Socket;
use IO::Socket;
use IO::Select;
use IO::Pipe;
use Sys::Syslog;
use POSIX qw(sys_wait_h setsid);
use Fcntl;

use Tirex;
use Tirex::Renderer;
use Tirex::Map;

#-----------------------------------------------------------------------------

die('refusing to run as root') if ($< == 0);

#-----------------------------------------------------------------------------
# Reading command line and config
#-----------------------------------------------------------------------------

my %opts = ();
GetOptions( \%opts, 'help|h', 'debug|d', 'config|c=s' ) or exit(2);

if ($opts{'help'})
{
    pod2usage(
        -verbose => 1,
        -msg     => "tirex-renderd-manager - tirex rendering manager\n",
        -exitval => 0
    );
}

$Tirex::DEBUG = $opts{'debug'} if ($opts{'debug'});

my $config_dir = $opts{'config'} || $Tirex::TIREX_CONFIGDIR;
my $config_file = $config_dir . '/' . $Tirex::TIREX_CONFIGFILENAME;
Tirex::Config::init($config_file);

#-----------------------------------------------------------------------------
# Initialize logging
#-----------------------------------------------------------------------------

openlog('tirex-renderd-manager', $Tirex::DEBUG ? 'pid|perror' : 'pid',
    Tirex::Config::get('renderd_syslog_facility', $Tirex::RENDERD_SYSLOG_FACILITY, qr{^(daemon|syslog|user|local[0-7])$}));

syslog('info', 'tirex-renderd-manager started');

Tirex::Config::dump_to_syslog();

#-----------------------------------------------------------------------------
# Daemonize unless in debug mode
#-----------------------------------------------------------------------------

if (! $Tirex::DEBUG)
{
    chdir('/')                     or die("Cannot chdir to /: $!");
    open(STDIN,  '<', '/dev/null') or die("Cannot read from /dev/null: $!");
    open(STDOUT, '>', '/dev/null') or die("Cannot write to /dev/null: $!");
    defined(my $pid = fork)        or die("Cannot fork: $!");
    exit(0) if ($pid);
    setsid()                       or die("Cannot start a new session: $!");
    open(STDERR, '>&STDOUT')       or die("Cannot dup stdout: $!");
}

#-----------------------------------------------------------------------------
# Write pid to pidfile
#-----------------------------------------------------------------------------
my $pidfile = Tirex::Config::get('renderd_pidfile', $Tirex::RENDERD_PIDFILE);

if (open(my $pidfh, '>', $pidfile)) 
{
    print $pidfh "$$\n";
    close($pidfh);
}
else
{
    syslog('err', "Can't open pidfile '$pidfile' for writing: $!\n");
    # keep going, we'd rather go on without a pidfile than stopping the show
}

#-----------------------------------------------------------------------------
# Set signal handler
#-----------------------------------------------------------------------------

$SIG{CHLD} = \&sigchld_handler;
$SIG{HUP}  = \&sighup_handler;
$SIG{TERM} = \&sigterm_handler;
$SIG{INT}  = \&sigterm_handler;

#-----------------------------------------------------------------------------
# Read renderer and map config
#-----------------------------------------------------------------------------

Tirex::Renderer->read_config_dir($config_dir);
Tirex::Map->read_config_dir($config_dir);

my @renderers = Tirex::Renderer->all();
syslog('info', 'Found config for renderers: %s', join(' ', map { $_->get_name(); } @renderers));

#-----------------------------------------------------------------------------

my $workers = {};
my @closed_children = ();

# children must check in every so often; note they will not check
# in during tile rendering so allow ample time.
my $alive_timeout = Tirex::Config::get('renderd_alive_timeout', $Tirex::RENDERD_ALIVE_TIMEOUT) * 60; # minutes -> seconds

# a child that has been sent a signal must react this quickly
my $hangup_timeout = 15;
my $term_timeout = 5;

while (1)
{
    foreach my $renderer (@renderers)
    {
        while ($renderer->num_workers() < $renderer->get_procs())
        {
            my $reader = IO::Pipe::End->new();
            my $writer = IO::Pipe::End->new();
            my $pipe = IO::Pipe->new($reader, $writer);
            $reader->fcntl(F_SETFD, 0); # unset close-on-exec
            $writer->fcntl(F_SETFD, 0); # unset close-on-exec
            $reader->blocking(0);
            $writer->blocking(0);

            my $pid = fork();
            if ($pid == 0) # child
            {
                $pipe->writer();

                execute_renderer($renderer, $pipe->fileno());

                # if we are here the execute failed
                ::syslog('err', "Cannot execute renderer %s (%s)", $renderer->get_name(), $renderer->get_path());
                exit($Tirex::EXIT_CODE_DISABLE);
            }
            elsif ($pid > 0) # parent
            {
                $pipe->reader();

                syslog('info', 'renderd %s started with pid %d', $renderer->get_name(), $pid);

                $workers->{$pid} = { 
                    pid          => $pid,
                    last_contact => time(),
                    handle       => $pipe,
                    renderer     => $renderer,
                };
                $renderer->add_worker($pid);
            }
            else
            {
                syslog('err', 'error in fork(): %s', $!);
            }
        }
    }

    my $select = IO::Select->new();
    foreach my $worker (values %$workers)
    {
        $select->add([$worker->{'handle'}, $worker]);
    }

    my $now = time();
    foreach my $handle_wrapper ($select->can_read($alive_timeout / 2))
    {
        my ($handle, $worker) = @$handle_wrapper;
        my $buf;
        $handle->read($buf, 9999);
        if (length($buf) > 0)
        {
            $worker->{'last_contact'} = $now;
        }
    }

    # remove dead children from the worker list
    while (my $pid = shift @closed_children)
    {
        $workers->{$pid}->{'handle'}->close();
        $workers->{$pid}->{'renderer'}->remove_worker($pid);
        delete $workers->{$pid};
    }

    # kill workers that haven't said anything for a while
    foreach my $worker (values %$workers) 
    { 
        if ($worker->{'last_contact'} < $now - $alive_timeout)
        {
            if (! defined($worker->{'killed'}) && defined($worker->{'terminated'}) && ($worker->{'terminated'} < $now - $term_timeout))
            {
                syslog('info', 'sending sigkill to pid %d', $worker->{'pid'});
                kill('KILL', $worker->{'pid'});
                $worker->{'killed'} = $now;
            }
            elsif (! defined($worker->{'terminated'}) && defined($worker->{'hungup'}) && ($worker->{'hungup'} < $now - $hangup_timeout))
            {
                syslog('info', 'sending sigterm to pid %d', $worker->{'pid'});
                kill('TERM', $worker->{'pid'});
                $worker->{'terminated'} = $now;
            }
            elsif (! defined($worker->{'hungup'}))
            {
                syslog('err', 'killing child with pid %d due to timeout', $worker->{'pid'});
                kill('HUP', $worker->{'pid'});
                $worker->{'hungup'} = $now;
            }
        }
    }
}

#-----------------------------------------------------------------------------

sub execute_renderer
{
    my $renderer    = shift;
    my $pipe_fileno = shift;

    $ENV{'TIREX_RENDERD_NAME'}            = $renderer->get_name();
    $ENV{'TIREX_RENDERD_PORT'}            = $renderer->get_port();
    $ENV{'TIREX_RENDERD_SYSLOG_FACILITY'} = $renderer->get_syslog_facility();
    $ENV{'TIREX_RENDERD_MAPFILES'}        = join(' ', map { $_->get_filename() } grep { $_->get_renderer() eq $renderer } Tirex::Map->all());
    $ENV{'TIREX_RENDERD_DEBUG'}           = $Tirex::DEBUG;
    $ENV{'TIREX_RENDERD_PIPE_FILENO'}     = $pipe_fileno;
    $ENV{'TIREX_RENDERD_ALIVE_TIMEOUT'}   = $alive_timeout - 20; # give the child 20 seconds less than what the parent uses as timeout to be on the safe side

    foreach my $key (%{$renderer->get_config()})
    {
        $ENV{"TIREX_RENDERD_CFG_$key"} = $renderer->{$key};
    }

    exec($renderer->get_path());
}


#-----------------------------------------------------------------------------
# Signal handler
#-----------------------------------------------------------------------------
sub sigchld_handler 
{
    while ((my $child = waitpid(-1, WNOHANG)) > 0) 
    {
        my $status = $?;
        syslog('warning', 'child %d terminated (%d)', $child, $status);
        push(@closed_children, $child);

        # if the return code of the child is 10, the renderer is disabled
        if ($status == 10)
        {
            my $renderer = $workers->{$child}->{'renderer'};
            @renderers = grep { $_ ne $renderer } @renderers;
        }
    }

    $SIG{'CHLD'} = \&sigchld_handler;
}

sub sighup_handler 
{
    syslog('info', 'hangup received, forwarding to children: %s', join(' ', keys %$workers));
#XXX we should re-read the config files here
    foreach my $pid (keys %$workers)
    {
        kill('HUP', $pid);
    }
    $SIG{'HUP'} = \&sighup_handler;
}

sub sigterm_handler 
{
    syslog('info', 'sigterm/int received, forwarding to children: %s', join(' ', keys %$workers));
    foreach my $pid (keys %$workers)
    {
        kill('HUP', $pid);
    }
    exit(0);
}


__END__

=head1 NAME

tirex-renderd-manager - program that spawns tirex-renderd processes

=head1 SYNOPSIS

tirex-renderd-manager [OPTIONS] 

=head1 OPTIONS

=over 4

=item B<--help>

Display help message.

=item B<-d>, B<--debug>

Run in debug mode, and pass on the debug flag to spawned processes

=item B<--config=DIR>

Use the DIR config directory instead of /etc/tirex.

=back

=head1 DESCRIPTION

tirex-renderd-manager starts as many tirex-renderd processes as given in the
configuration, and monitors them.

The renderd manager does not handle render requests in any way; these
are read directly from a local UDP socket by the individual tirex-ren-
derd processes.

The renderd manager expects each tirex-renderd process to send an
"alive" message in regular intervals, and will kill the process if it
does not do so in time.

In addition, if the manager receives a HANGUP signal, it will relay
this signal to all tirex-renderd children, causing them to exit after
completing their current request.

If this process receives a HUP or TERM signal, it sends a HUP signal 
to all children and continues (if the signal received was HUP) or
terminates (if TERM).

=head1 FILES

=over 4

=item F</etc/tirex/tirex.conf>

The configuration file. See tirex.conf(5) for further details.

=back

=head1 DIAGNOSTICS

The renderd starter logs to the I<daemon> syslog facility unless configured
otherwise. In debug mode, logging is also copied to stderr.

=head1 AUTHORS

Frederik Ramm <frederik.ramm@geofabrik.de>, Jochen Topf
<jochen.topf@geofabrik.de> and possibly others.

=cut

#-- THE END ------------------------------------------------------------------
