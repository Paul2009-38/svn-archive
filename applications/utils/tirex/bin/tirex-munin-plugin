#!/usr/bin/perl
#------------------------------------------------------------------------------
#
#  Tirex Tile Rendering System
#
#  tirex-munin-plugin
#
#-----------------------------------------------------------------------------
#
#  Reads the status of the running tirex-master process from shared memory,
#  outputs munin compatible values.
#
#  Usage:
#  tirex-munin-plugin [config]
#
#------------------------------------------------------------------------------
#
#  Copyright (C) 2010  Frederik Ramm <frederik.ramm@geofabrik.de> and
#                      Jochen Topf <jochen.topf@geofabrik.de>
#  
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; If not, see <http://www.gnu.org/licenses/>.
#
#-----------------------------------------------------------------------------

use strict;
use warnings;

use JSON;

use Tirex;
use Tirex::Status;

#------------------------------------------------------------------------------

my $status_obj = Tirex::Status->new();
my $status = $status_obj->read();
die unless defined $status;
my $d = JSON::from_json($status);
my $config = scalar(@ARGV) && ($ARGV[0] eq "config");

die "unknown plugin name - expected tirex_totals_by_zoom, tirex_timings_by_zoom, tirex_buckets, tirex_queue, tirex_age" 
    unless ($0 =~ (/^(.*\/)?tirex_(totals_by_zoom|timings_by_zoom|buckets|queue|age)(_(\S+))?$/));
my ($mode, $mapname) = ($2, $4);

my $mapid = $mapname;
my $dotmapid = "";
if (defined $mapid)
{
    $mapid =~ tr/A-Za-z0-9/_/cs;
    $dotmapid = "_$mapid";
}

if ($mode eq "buckets")
{
    if ($config)
    {
        printf "graph_title Active requests\n";
        printf "graph_vlabel number of active requests\n";
        printf "graph_category tirex\n";
    }
    my $t = "AREA";
    foreach my $bucket (sort { $b->{minprio} <=> $a->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
    {
        my $id = $bucket->{name};
        $id =~ tr/A-Za-z0-9/_/cs;
        $id = "req_$id";

        if ($config)
        {
            printf "%s.info Number of requests currently processing for ".
                "bucket %s (stacked graph)\n", $id, $bucket->{name};
            printf "%s.label rendering in %s\n", $id, $bucket->{name};
            printf "%s.type GAUGE\n", $id;
            printf "%s.draw $t\n", $id;
	        my $t = "STACK";
        }
        else
        {
            printf "%s.value %d\n", $id, $bucket->{numproc};
        }
    }
    exit(1);
}

if (($mode eq 'timings_by_zoom') || ($mode eq 'totals_by_zoom'))
{
    # define classes for zoom levels. each class will be reported as one
    # Munin variable and thus result in one line in a standard diagram.
    # note that if you change this you should purge your Munin rrd files.

    my $classes = [ "0-5", "6-9", "10-12", "13-14", "15-16", "17-" ];

    my $short = ($mode eq 'timings_by_zoom') ? 'tibz' : 'tobz';

    if ($config)
    {
        print "graph_title ";
        printf "%s", ($mode eq "timings_by_zoom") ? "Render time" : "Request count";
        print " in map '$mapname'" if (defined($mapname));
        print "\n";
        print "graph_vlabel ";
        printf "%s", ($mode eq "timings_by_zoom") ? "milliseconds/second\n" : "requests/second\n";
        print "graph_category tirex\n";
        for (my $i=0; $i<scalar(@$classes); $i++)
        {
           my $s = ($classes->[$i] =~ /-/) ? "s" : "";
           print "$short$i$dotmapid.info ";
           printf "%s", ($mode eq "timings_by_zoom") ? "Time spent rendering" : "Requests completed";
           print " per second on zoom level$s ".$classes->[$i]."\n";
           print "$short$i$dotmapid.label zoom levels ".$classes->[$i]."\n";
           print "$short$i$dotmapid.type DERIVE\n";
           print "$short$i$dotmapid.min 0\n";
        }
    }
    else
    {
        my $r = [];
        my $key = ($mode eq 'timings_by_zoom') ? 'sum_render_time' : 'count_rendered';
        for (my $i = 0; $i<scalar(@$classes); $i++) { $r->[$i] = 0; }
        foreach my $map (keys(%{$d->{'rm'}->{'stats'}->{$key}}))
        {
            next if (defined($mapname) && $map ne $mapname);
            my $mapstat = $d->{'rm'}->{'stats'}->{$key}->{$map};
            for (my $z=0; $z<scalar(@$mapstat); $z++)
            {
                next unless defined($mapstat->[$z]);
                for (my $i = 0; $i<scalar(@$classes); $i++)
                {
                    my ($from, $to) = ($classes->[$i] =~ /-/) ? split(/-/, $classes->[$i]) : ($classes->[$i], $classes->[$i]);
                    $from=0 unless defined($from);
                    $to = 32767 unless defined($to);
                    if ($z>=$from && $z<=$to)
                    {
                        $r->[$i] += $mapstat->[$z];
                        last;
                    }
                }
            }
        }
        for (my $i=0; $i<scalar(@$classes); $i++)
        {
            printf "$short$i$dotmapid.value %d\n", $r->[$i] if defined($r->[$i]);
        }
    }
    exit 1;
}

if ($mode eq 'queue')
{
    if ($config)
    {
        printf "graph_title Queued requests\n";
        printf "graph_vlabel queue size\n";
        printf "graph_category tirex\n";
        my $t = "AREA";
        foreach my $b (sort { $b->{minprio} <=> $a->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
        {
            my $id = $b->{name};
            $id =~ tr/A-Za-z0-9/_/cs;
            $id = "queue_$id";

            printf "%s.info Number of requests currently queued in ".
                "bucket %s (prio %s-%s)\n", $id, $b->{name}, $b->{minprio}, ($b->{maxprio} > 0) ? $b->{maxprio} : "";
            printf "%s.label queued in %s\n", $id, $b->{name};
            printf "%s.type GAUGE\n", $id;
            printf "%s.draw $t\n", $id;
	    $t = "STACK";
        }
    }
    else
    {
        my $c = {};
        foreach my $pq (@{$d->{'queue'}->{'prioqueues'}})
        {
            my $prio = $pq->{'prio'};
            foreach my $bucket (sort { $a->{minprio} <=> $b->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
            {
#                if ($bucket->for_prio($prio))
                if (($bucket->{minprio} eq "" || $bucket->{minprio} <= $prio) && ($bucket->{maxprio} == 0 || $bucket->{maxprio} >= $prio))
                {
                    $c->{$bucket->{name}} += $pq->{'size'};
                    last;
                }
            }
        }
        foreach my $bucket (sort { $b->{minprio} <=> $a->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
        {
            my $id = $bucket->{name};
            $id =~ tr/A-Za-z0-9/_/cs;
            $id = "queue_$id";
            printf "%s.value %d\n", $id, defined($c->{$bucket->{name}}) ? $c->{$bucket->{name}} : 0;
        }
    }
}

if ($mode eq 'age')
{
    if ($config)
    {
        printf "graph_title Request age\n";
        printf "graph_vlabel age in seconds\n";
        printf "graph_category tirex\n";
        printf "graph_args --lower-limit 1 --logarithmic --units=si\n";
        foreach my $b (sort { $b->{minprio} <=> $a->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
        {
            my $id = $b->{name};
            $id =~ tr/A-Za-z0-9/_/cs;
            $id = "age_$id";

            printf "%s.info Age of oldest request currently queued in ".
                "bucket %s (prio %s-%s)\n", $id, $b->{name}, $b->{minprio}, ($b->{maxprio} > 0) ? $b->{maxprio} : "";
            printf "%s.label queued in %s\n", $id, $b->{name};
            printf "%s.type GAUGE\n", $id;
            printf "%s.draw LINE2\n", $id;
        }
    }
    else
    {
        my $c = {};
        foreach my $pq (@{$d->{'queue'}->{'prioqueues'}})
        {
            my $prio = $pq->{'prio'};
            foreach my $bucket (sort { $a->{minprio} <=> $b->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
            {
#                if ($bucket->for_prio($prio))
                if (($bucket->{minprio} eq "" || $bucket->{minprio} <= $prio) && ($bucket->{maxprio} == 0 || $bucket->{maxprio} >= $prio))
                {
                    $c->{$bucket->{name}} = $pq->{'age_first'} if (!defined($c->{$bucket->{name}}) || defined($pq->{'age_first'}) && $pq->{'age_first'} > $c->{$bucket->{name}});
                    last;
                }
            }
        }
        foreach my $bucket (sort { $b->{minprio} <=> $a->{minprio} } @{$d->{'rm'}->{'buckets'}}) 
        {
            my $id = $bucket->{name};
            $id =~ tr/A-Za-z0-9/_/cs;
            $id = "age_$id";
            printf "%s.value %d\n", $id, defined($c->{$bucket->{name}}) ? $c->{$bucket->{name}} : 0;
        }
    }
}

#-- THE END -------------------------------------------------------------------
