#!/usr/bin/env ruby

=begin Copyright (C) 2005 Ben Gimpert (ben@somethingmodern.com)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

=end

require 'cgi'
require 'fileutils'
require 'find'
require 'net/http'
require 'timeout'
require 'uri'

require 'tiger/tiger'

LOGIN = "ben_tiger@somethingmodern.com"
PASSWORD = "january"
DEBUG = false

DEMONIZE = ! DEBUG
THIS_DIR = File.expand_path(File.dirname(__FILE__))
TMP_DIR = "#{THIS_DIR}/tmp"
FIPS_DB_PATH = "#{THIS_DIR}/fips_db.txt"
FINISHED_DB_PATH = "#{THIS_DIR}/finished_db.txt"
FIRST_FIPS = [
	"06075",  # San Francisco
	"06041",  # Marin (greater San Francisco, CA)
	"06001",  # Alameda (greater San Francisco, CA)
	"06085",  # Santa Clara (greater San Francisco, CA)
	"06081",  # San Mateo (greater San Francisco, CA)
	"17031",  # Cook (Chicago, IL)
	"36061",  # New York (Manhattan)
	"11001",  # District of Columbia (Washington DC)
]

def usage
	$stderr.print <<EOF
Pass the root of the TIGER 2005 download as the first argument, with
an optional starting street number as the second.

Usage: $ ./to_osm /some_dir/tiger2005fe/ [street-num]

EOF
	exit(1)
end

def demonize
	if DEMONIZE
		# from "http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/87467"
		exit if fork                   # Parent exits, child continues.
		Process.setsid                 # Become session leader.
		exit if fork                   # Zap session leader.
		Dir.chdir "/"                  # Release old working directory.
		File.umask 0000                # Ensure sensible umask.
		STDIN.reopen "/dev/null"       # Free file descriptors and point them at the log.
		STDOUT.reopen "#{THIS_DIR}/to_osm.log", "a"
		STDERR.reopen STDOUT
		File.open("#{THIS_DIR}/to_osm.pid", "w") { |f| f.puts $$ }
	end
	yield
end

def read_rt(zip)
	FileUtils.rm_rf(TMP_DIR) if File.exist?(TMP_DIR)
	FileUtils.mkdir_p(TMP_DIR)
	$stderr.puts "reading RT1 and RT2 from \"#{zip}\""
	FileUtils.cp(zip, "#{TMP_DIR}/current.zip")
	rt1_s, rt2_s = nil, nil
	Dir.chdir(TMP_DIR) do
		`/usr/bin/unzip ./current.zip`
		Dir["*.RT1"].each { |rt1_f| rt1_s = IO.read(rt1_f) }
		Dir["*.RT2"].each { |rt2_f| rt2_s = IO.read(rt2_f) }
	end
	[rt1_s, rt2_s]
end

def osm(method_class, url_snippet, req_body = nil)
	$stderr.puts "#{method_class.name}(\"#{url_snippet}\") =\n#{req_body}" if DEBUG
	Net::HTTP.start("www.openstreetmap.org") do |http|
		url = "/api/0.3/#{url_snippet}"
		req = method_class.new(url)
		req.basic_auth(LOGIN, PASSWORD)
		resp = http.request(req, req_body)
		$stderr.puts "request(\"#{url_snippet}\") =\n#{req_body}" if DEBUG
		$stderr.puts "resp.body = #{resp.body}" if DEBUG
		case resp.code.to_i
		when 400
			throw "Bad Request(400) on \"#{url_snippet}\""
		when 401
			throw "Authorization Required(401) on \"#{url_snippet}\" with #{LOGIN}/#{PASSWORD}"
		when 404
			throw "Not Found(404) on \"#{url_snippet}\""
		when 410
			throw "Gone(410) on \"#{url_snippet}\""
		when 500
			throw "Internal Server Error(500) on \"#{url_snippet}\""
		when 200
			return resp.body
		end
	end
end

def osm_get(url_snippet)
	osm(Net::HTTP::Get, url_snippet)
end

def osm_put(url_snippet, req_body)
	osm(Net::HTTP::Put, url_snippet, req_body)
end

def hash_to_tags(h)
	s = ''
	h.each_pair do |key, value|
		s += "<tag k=\"#{key}\" v=\"#{value}\"/>\n"
	end
	s
end

def osm_xml
	<<EOF
<?xml version="1.0"?>
<osm version="0.3" generator="Tiger Import">
#{yield}
</osm>
EOF
end

def create_node(lat, long, tags = {})
	xml = osm_xml do
		"<node lat=\"#{lat}\" lon=\"#{long}\" id=\"0\">\n" +
		hash_to_tags(tags) +
		"</node>"
	end
	node = osm_put("node/0", xml)
	node.to_i
end

def create_segment(from_node, to_node, tags = {})
	xml = osm_xml do
		"<segment from=\"#{from_node}\" to=\"#{to_node}\" id=\"0\">\n" +
		hash_to_tags(tags) +
		"</segment>"
	end
	segment = osm_put("segment/0", xml)
	segment.to_i
end

def create_way(seg_ids, tags = {})
	xml = osm_xml do
		"<way id=\"0\">\n" +
		seg_ids.map { |seg_id| "<seg id=\"#{seg_id}\"/>\n" }.join +
		hash_to_tags(tags) +
		"</way>"
	end
	way = osm_put("way/0", xml)
	way.to_i
end

def backoff
	delay = 1.25  # seconds, must be > 1
	loop do
		begin
			return yield
		rescue TimeoutError =>ex
			$stderr.puts "timeout in backoff block, \"#{ex.message}\" #{ex.backtrace.join(" -> ")}"
		rescue =>ex
			$stderr.puts "problem in backoff block, \"#{ex.message}\" #{ex.backtrace.join(" -> ")}"
		end
		$stderr.puts "sleeping #{delay} seconds at #{Time.now}"
		sleep(delay)
		delay = delay ** 2  # exponential backoff
		throw "Backoff delay over four hours" if delay > 60 * 60 * 4
	end
end

def create_street_raw(street)
	prev_node_id = nil
	seg_ids = []
	total_lat, total_long = 0, 0
	street.points.each do |pt|
		lat, long = pt.lat, pt.long
		total_lat += lat
		total_long += long
		if prev_node_id.nil?
			prev_node_id = create_node(lat, long)
		else
			next_node_id = create_node(lat, long)
			seg_ids << create_segment(prev_node_id, next_node_id)
			prev_node_id = next_node_id
		end
	end
	av_lat = total_lat / street.points.length
	av_long = total_long / street.points.length
	$stderr.puts "\tcenter lat, long = #{av_lat}, #{av_long}"
	tags = {
		"name" => street.name,
		"from_zip" => street.from_zip,
		"to_zip" => street.to_zip,
	}
	way_id = create_way(seg_ids, tags)
end

def create_street(street)
	# with error checking and backoff
	throw "Attempt to create nil street" if street.nil?
	throw "Attempt to create street with less than two coordinates" if street.points.nil? || (street.points.length < 2)
	way_id = backoff { create_street_raw(street) }
	$stderr.puts "\tcreated way with ID #{way_id}"
	way_id
end

def read_tiger_county_zip(zip)
	$stderr.puts "reading county ZIP file \"#{zip}\""
	rt1, rt2 = read_rt(zip)
	streets = Tiger::import(rt1, rt2).sort
	$stderr.puts "\tnumber of streets = #{streets.length}"
	streets
end

def include_num_in_ranges(num, ranges)
	new_ranges = []
	ranges.each_index do |i|
		new_ranges = ranges[i]
	end
	new_ranges.each_index do |i|
		if new_ranges[i].last == num - 1
			new_ranges[i] = (new_ranges[i].first..num)
			return new_ranges
		end
	end
	new_ranges << (num..num)
end

class Indices

	def Indices.from_files(fips_db_path, finished_db_path)
		indices = Indices.new
		if File.exist?(fips_db_path)
			$stderr.puts "reading TIGER county database from \"#{fips_db_path}\""
			from_index = 0
			File.open(fips_db_path) do |f|
				f.readlines.each do |line|
					next if line.strip.empty?
					fips, num_streets = line.split("\t")
					num_streets = num_streets.to_i
					range = from_index..(from_index + num_streets - 1))
					indices.set_range(fips, range)
					from_index += num_streets - 1
				end
			end
		end
		if File.exist?(finished_db_path)
			$stderr.puts "reading finished street database from \"#{finished_db_path}\""
			File.open(finished_db_path) do |f|
				f.readlines.each do |line|
					next if line.strip.empty?
					finished_range = eval(line)
					indices.add_finished(finished_range)
				end
			end
		end
		indices
	end

	def initialize
		@map = {}  # FIPS county code => range of street indices
		@reverse_map = {}  # range of street indices => FIPS county code
		@finished = []  # array of ranges of indices already finished
	end

	def set_range(fips, range)
		throw "Already have a range for FIPS code \"#{fips}\"" if @map.has_key?(fips)
		@map[fips] = range
		@reverse_map[range] = fips
	end

	def add_finished(range)
		if range.is_a?(Numeric)
			num = range
			@finished = include_num_in_ranges(num, @finished)
		else
			@finished << range
		end
	end

	def finished?(i)
		@finished.each do |range|
			return true if range.member?(i)
		end
		false
	end

	def index_to_fips(i)
		@reverse_map.keys.each do |range|
			return @reverse_map[range] if range.memeber?(i)
		end
		throw "Could not find FIPS code for index #{i}"
	end

	def fips_to_range(fips)
		@map.keys.each do |sub_fips|
			return @map[sub_fips] if sub_fips == fips
		end
		throw "Could not find range for FIPS code \"#{fips}\""
	end

	def num_streets
		range_maxes = []
		@reverse_map.keys.each do |range|
			range_maxes << range.max
		end
		range_maxes.max + 1
	end

	def num_finished
		num = 0
		@finished.each do |range|
			num += range.last - range.first
		end
		num
	end

	def percent_finised
		((num_finished.to_f / num_streets) * 100).to_s[0..5].to_f
	end

	def each
		fips_a = []
		FIRST_FIPS.each do |fips|
			fips_a << fips
		end
		@map.keys.each do |fips|
			fips_a << fips
		end
		fips_a = fips_a.uniq
		fips_a.each do |fips|
			fips_to_range(fips).each do |i|
				next if finished?(i)
				just_finished = yield(i, fips)
				add_finished(i) if just_finished
			end
		end
	end

end

usage unless ARGV.length >= 1
path = File.expand_path(ARGV.first)
usage unless File.exist?(path) && File.directory?(path)

demonize do
	$stderr.puts "starting the TIGER -> OSM import at #{Time.now}"
	unless File.exist?(FIPS_DB_PATH)
		$stderr.puts "creating the TIGER county database"
		zip_paths = []
		Find.find(path) do |f|
			zip_paths << f if f =~ /\.zip$/i
		end
		File.open(FIPS_DB_PATH, "w") do |f|
			zip_paths.sort.each do |zip_path|
				zip_path  =~ /tgr(\d{5})\.zip$/i
				fips = $1
				streets = read_tiger_county_zip(zip_path)
				f.puts [fips, streets.length].join("\t")
				f.flush
			end
		end
	end
	indices = Indices.from_files(FIPS_DB_PATH, FINISHED_DB_PATH)
	File.open(FINISHED_DB_PATH, "a") do |finished_io|
		finished_index_ranges = []
		begin
			fips, streets = nil
			indices.each do |i, i_fips|
				if fips.nil? || (i_fips != fips)
					fips = i_fips
					streets = nil
					Find.find(path) do |f|
						if f =~ /#{fips}\.zip$/i
							streets = read_tiger_county_zip(f)
							break
						end
					end
					throw "Could not find TIGER ZIP for FIPS \"#{fips}\"" if streets.nil?
				end
				street = streets[i - indicies.fips_to_range(fips).first]
				create_street(street) unless DEBUG
				$stderr.puts "created street number #{i} at #{Time.now}"
				$stderr.puts "overall TIGER -> OSM import is #{indices.percent_finished}% complete" if (i % 10).zero?
				finished_index_ranges = include_num_in_ranges(i, finished_index_ranges)
				true  # we've finished this street
			end
		ensure
			$stderr.puts "writing #{finished_index_ranges.length} finished index range(s) to database"
			finished_index_ranges.each do |range|
				finished_io.puts "(#{range})"
			end
		end
	end
end

